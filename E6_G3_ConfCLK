// Tipos
typedef unsigned int uint32_t;

// Bases
#define RCC_BASE    0x40021000
#define FLASH_BASE  0x40022000

// Registros RCC
#define RCC_CR      (*(volatile uint32_t*)(RCC_BASE + 0x00))
#define RCC_CFGR    (*(volatile uint32_t*)(RCC_BASE + 0x04))

// Registro FLASH
#define FLASH_ACR   (*(volatile uint32_t*)(FLASH_BASE + 0x00))

// Bits útiles RCC_CR
#define RCC_CR_HSEON   (1u << 16)
#define RCC_CR_HSERDY  (1u << 17)
#define RCC_CR_PLLON   (1u << 24)
#define RCC_CR_PLLRDY  (1u << 25)

// Campos RCC_CFGR
// SW (1:0)    -> 10 = PLL
// SWS (3:2)   -> 10 = PLL usado como SYSCLK
// HPRE (7:4)  -> 1000 = AHB /2
// PPRE1(10:8) -> 100  = APB1 /2
// PPRE2(13:11)-> 101  = APB2 /4
// PLLSRC(16)  -> 1 = HSE como fuente del PLL
// PLLXTPRE(17)-> 1 = HSE/2 antes del PLL
// PLLMUL(21:18)-> 0010 = ×4
#define CFGR_SW_PLL      (0x2u << 0)
#define CFGR_SWS_PLL     (0x2u << 2)
#define CFGR_HPRE_DIV2   (0x8u << 4)
#define CFGR_PPRE1_DIV2  (0x4u << 8)
#define CFGR_PPRE2_DIV4  (0x5u << 11)
#define CFGR_PLLSRC_HSE  (1u << 16)
#define CFGR_PLLXTPRE_2  (1u << 17)
#define CFGR_PLLMULx4    (0x2u << 18)

// FLASH: latencia (<=24 MHz -> 0 wait states está bien)
#define FLASH_LATENCY_0  0x0u
#define FLASH_ACR_LATENCY_MASK 0x7u

// Pequeña espera bloqueante
static void wait_ready(volatile uint32_t* reg, uint32_t mask) {
    while ( (*reg & mask) == 0u ) { /* spin */ }
}

void clock_init(void)
{
    // 1) Latencia de flash adecuada (16 MHz -> 0 WS). Prefetch opcional.
    FLASH_ACR = (FLASH_ACR & ~FLASH_ACR_LATENCY_MASK) | FLASH_LATENCY_0;

    // 2) Habilitar HSE y esperar estable
    RCC_CR |= RCC_CR_HSEON;
    wait_ready(&RCC_CR, RCC_CR_HSERDY);

    // 3) Configurar prescalers y PLL (AÚN sin encender el PLL)
    //    - AHB /2
    //    - APB1 /2
    //    - APB2 /4
    //    - PLL fuente = HSE/2, multiplicador ×4
    uint32_t cfgr = RCC_CFGR;
    // limpiar campos que vamos a setear
    cfgr &= ~((0xFu << 4) | (0x7u << 8) | (0x7u << 11) | (1u<<16) | (1u<<17) | (0xFu<<18) | (0x3u<<0));
    cfgr |=  CFGR_HPRE_DIV2
          |  CFGR_PPRE1_DIV2
          |  CFGR_PPRE2_DIV4
          |  CFGR_PLLSRC_HSE
          |  CFGR_PLLXTPRE_2
          |  CFGR_PLLMULx4;
    RCC_CFGR = cfgr;

    // 4) Encender PLL y esperar que esté listo
    RCC_CR |= RCC_CR_PLLON;
    wait_ready(&RCC_CR, RCC_CR_PLLRDY);

    // 5) Cambiar SYSCLK a PLL y esperar confirmación
    RCC_CFGR = (RCC_CFGR & ~(0x3u << 0)) | CFGR_SW_PLL;
    while ( ((RCC_CFGR >> 2) & 0x3u) != 0x2u ) { /* espera SWS=PLL */ }
}